<img src="drawing.png"/>

# TriftGeoclaw
This repository quantifies the impulse waves induced by snow avalanches in the future [Trift reservoir](https://www.researchgate.net/publication/313646761_L'amenagement_hydroelectrique_de_Trift) (Gadmen, Bern, Switerland).

This work needs Christophe Ancey's [AVAC](https://github.com/cancey/avac.git) code's results files and depends on David George's [Geoclaw](https://www.clawpack.org/geoclaw) module from Randall J. Leveque's [Clawpack](https://www.clawpack.org/).

## Desired output
A simulation of the impulse wave generated by the snow avalanche simulated by AVAC.

<img src="pyv-wave.gif">

## Requirements
- [Clawpack](https://www.clawpack.org/installing_pip.html#install-quick-all)
- [liblapack-dev](https://www.netlib.org/lapack/) and [libopenblas-dev](http://www.openmathlib.org/OpenBLAS/)
- `python>=3.7` (in order to use [pathlib](https://docs.python.org/3/library/pathlib.html) and [PyYAML](https://pypi.org/project/PyYAML/)). The required packages to install are listed in [requirements.txt](requirements.txt):
    - [matplotlib](https://pypi.org/project/matplotlib/)
    - [PyYAML](https://pypi.org/project/PyYAML/) for reading the `config.yaml` file.
    - [scikit-image](https://pypi.org/project/scikit-image/) for treating the bathymetry.

## Lake tsunami modelling

The data in the output directory is used to introduce an avalanche with ajusted fluxes according to the difference in density between the water and the snow.

To run the simulation, simply use `make`. The directory from which to read the AVAC results can be specified in `make data` as follows:
```Makefile
echo $PWD  # You should be in the TriftGeoClaw directory
make new  # Compile fortran codes, you only need to do this once
make qinit  # Create qinit.xyz (initial surface)
make data AVAC_outdir=../avac/_output  # Prepare the datafiles,
                                       # ../avac/_output is the default value
make output  # compute
```

## Lake as initial solution: `makeqinit.py`

The `skimage.morphology.flood` is used to fill the dam's bassin up to some altitude from a given seed point. To easen up the usage, an interactive matplotlib figure is used to click on some location which will be the seed and fill up to any altitude entered through text input ([makeqinit.py](makeqinit.py)). The lake level, the flood seed and the dilation radius can also be specified in `config.yaml`:

The dilation is needed because of an interpolation error, causing waves at the edge of steep borders.

## Flux introduction

The mode of mass and momentum introduction can be chosen in `config.yaml:inflow_mode`. It can be either `bc` (the boundary conditions) or `src` (through the source term, acting like curvilinear boundary conditions).

### From the boundary conditions (`bc`)

The saved files from the AVAC results are read by the `setprob.f90` through the `helpers.f90` module. During the simulation, the `bc2amr.f90` subroutine then reads the appropriate section of the data to introduce the flow with a damping coefficient, interpolated in time then in space.

With this mode of flux introcution, the variable `q_avac` has 4 dimensions: `q_avac(time, side, i, variable)` where
- `time` is the index of the fgout frame from AVAC with time `t`,
- `side` is the index of the boundary condition (left, right, bottom, top),
- `i` is the index along a side, it goes from 1 to `config.yaml:bc_size`,
- `variable` is the index that specifies wich of `x`, `y`, `h`, `hu` or `hv` to get.

The initialization of this array is done in [helpers](helpers.f90): `init_bc()`.

### From the source term (`src`)

Same as boundary condition but with `b4step2.f90` instead of `bc2amr.f90`. This enforces the results from AVAC with the damping coefficient on all cells whose level `z` is higher than `lake_level+overhang`. It is first interpolated in time, then in space. It is a curvilinear boundary condition if you will.

With this mode of flux introcution, the variable `q_avac` has 4 dimensions again: `q_avac(time, variable, x, y)` where
- `time` is the index of the fgout frame from AVAC with time `t`,
- `variable` is the index that specifies wich of `h`, `hu` or `hv` to get.
- `x` is the index along the x-position on the AVAC fgout grid,
- `y` is the index along the y-direction ont he AVAC fgout grid,

The initialization of this array is done in [helpers](helpers.f90): `init_src_fgout_bin()`.

<!-- ## Flowchart <img src=flowchart.png> -->

## Plotting a fixed grid output (fgout_grid) with pyvista

> Only binary format at the moment

```bash
python pyvista_fgout_grid.py \
[outdir] \
[--color_by -c variable ] \ # variable is one of h, hu, hv, z, b, dh, ds
[--gridno -g grid_number] \
[--cmaps -m mpl_colormap_bathy mpl_colormap_variable] \
[--clim -l mpl_colormap_variable_lower mpl_colormap_variable_upper] \
[--file_name -f output_gif_movie_file_name]
